@inherits ControlBase
@implements IDisposable
@typeparam TItem
@inject IJSRuntime JsRuntime

<Dropdown FullWidth="true">
    <Trigger>
        <AuroraButton style="display:block;width:100%" Label="Temp" />
    </Trigger>
    <Content>
        <ul class="dropdown-list" style="max-height:310px;position:relative" data-dropdown-dismiss @ref="itemList">
            @foreach (var item in Items)
            {
                <li @onclick="_ => SelectedItem = item">
                    @if (ItemTemplate == null) {
                        @DisplayOf(item);
                    } else {
                        @ItemTemplate(item); // N.B. I tried doing @(ItemTemplate == null ? DisplayOf(item) : ItemTemplate(item)) but this didn't work correctly (I think maybe due to implicit typecasting of the renderfragment to an object? maybe?)
                    }
                </li>
            }
        </ul>
    </Content>
</Dropdown>

@code {

    [Parameter] public IEnumerable<TItem> Items { get; set; }

    private TItem selectedItem;
    [Parameter] public TItem SelectedItem {
        get => selectedItem;
        set {
            if (!Equals(value, selectedItem)) {
                selectedItem = value;
                SelectedItemChanged.InvokeAsync(SelectedItem);
                SelectedValueChanged.InvokeAsync(SelectedValue);
            }
        }
    }

    [Parameter] public object SelectedValue {
        get => ValueOf(SelectedItem);
        set => SelectedItem = FindItemFromValue(value);
    }

    [Parameter] public EventCallback<TItem> SelectedItemChanged { get; set; }
    [Parameter] public EventCallback<object> SelectedValueChanged { get; set; }

    [Parameter] public Func<TItem, object> ValueMember { get; set; }
    [Parameter] public Func<TItem, object> DisplayMember { get; set; }

    [Parameter] public RenderFragment<TItem> ItemTemplate { get; set; }


    object ValueOf(TItem item) =>
        item == null || ValueMember == null ? item : ValueMember(item);

    object DisplayOf(TItem item) =>
        item == null || DisplayMember == null ? item : DisplayMember(item);

    TItem FindItemFromValue(object value) =>
        Items.FirstOrDefault(i => Equals(value, ValueOf(i)));


    ElementReference itemList;
    protected override void OnAfterRender(bool firstRender) {
        // If first render, we want to init a new scrollbar.
        // If non-first render, make the scrollbar update it's size incase there has been any items added or removed
        JsRuntime.InvokeVoidAsync("auroraUi.scrollbar." + (firstRender ? "init" : "update"), itemList);
    }

    public void Dispose() {
        JsRuntime.InvokeVoidAsync("auroraUi.scrollbar.dispose", itemList);
    }
}